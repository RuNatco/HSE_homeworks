# Построение min-кучи за O(N): доказательство

Дан массив arr длины n. Нужно преобразовать его в min-heap за время O(N).

Рассмотрим алгоритм makeheap, который работает in-place:

```text
makeheap(arr):
    n = len(arr)
    for i from n//2 - 1 down to 0:
        sift_down(arr, i, n)
```

Здесь sift_down(arr, i, n) — это операция «просеивание вниз» элемента с индекса i в пределах первых n элементов массива. Предполагаем, что поддеревья детей уже являются кучами.

Массив, представляющий кучу, можно рассматривать как почти полное двоичное дерево:
- Индекс 0 — корень.
- Для вершины с индексом i:
  - левый ребёнок: 2 * i + 1,
  - правый ребёнок: 2 * i + 2.
- Узлы с индексами от n//2 до (n - 1) — это листья.
- Узлы с индексами от 0 до (n//2 - 1) — это внутренние узлы (имеют хотя бы одного ребёнка).

Листья уже являются кучами, потому что у них нет детей, значит, для них условие кучи выполняется автоматически. Поэтому в алгоритме makeheap мы вызываем sift_down только для внутренних узлов — от (n//2 - 1) до 0.

Рассмотрим узел на некоторой высоте h от листьев:
- листья имеют высоту 0,
- их родители — высоту 1,
- и так далее до корня.
В худшем случае при вызове sift_down элемент из этого узла может опуститься до самого низа, то есть пройти не более h уровней.

Значит, стоимость одного sift_down для узла высоты h — это O(h).

Рассмотрим почти полное двоичное дерево (как у кучи). Чем выше по дереву, тем меньше узлов (примерно в два раза меньше на каждом уровне).

Обозначим максимальную высоту дерева через H ≈ ⌊log n⌋.

Посчитаем суммарное время работы всех вызовов sift_down при выполнении makeheap.

Для высоты h:
- число узлов не больше n / 2^{h+1},
- стоимость одного sift_down — O(h).

Тогда вклад всех узлов высоты h в общее время: 
```text
O(h) * (n / 2^{h+1})
```

Складываем по всем высотам от 0 до H:
```text
T(n) ≤ Σ (по h от 0 до H) [ n / 2^{h+1} * C * h ]
     = C * n * Σ (по h от 0 до H) [ h / 2^{h+1} ]
```
C — некоторая константа.

При больших n можно считать, что сумма по h от 0 до H не превосходит бесконечной суммы:
```text
Σ (по h от 0 до H) [ h / 2^{h} ] ≤ Σ (по h от 0 до ∞) [ h / 2^{h} ]
```

Обозначим:
```text
S = Σ (по h от 0 до ∞) [ h / 2^{h} ]
```

Выпишем ряд:
```text
S   = 0/1 + 1/2 + 2/4 + 3/8 + 4/16 + 5/32 + ...
S/2 =       0/2 + 1/4 + 2/8 + 3/16 + 4/32 + ...
```

Вычтем S/2 из S поэлементно:
```text
S - S/2 = (1/2) + (2/4 - 1/4) + (3/8 - 2/8) + (4/16 - 3/16) + ...
        = 1/2 + 1/4 + 1/8 + 1/16 + ...
```

Правая часть — это геометрическая прогрессия с первым членом 1/2 и знаменателем 1/2:
```text
1/2 + 1/4 + 1/8 + 1/16 + ... = 1
```

Значит:
```text
S - S/2 = 1
S/2 = 1
S = 2
```

Подставляем S в оценку T(n)
```text
T(n) ≤ C * n * (1/2) * 2 = C * n
```

То есть:
```text
T(n) = O(n)
```

Вывод: алгоритм makeheap, который просеивает вниз все внутренние узлы, начиная с индекса n//2 - 1 и заканчивая корнем, работает за линейное время O(N).

Таким образом:
- хотя один sift_down в корне может стоить O(log N),
- таких «дорогих» узлов немного,
- у большинства узлов высота маленькая,
- поэтому суммарное время по всем узлам даёт линейную оценку O(N).
